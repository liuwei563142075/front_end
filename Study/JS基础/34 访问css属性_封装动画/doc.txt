1.学习了另一种访问【内嵌式】css属性的方式：
方式1：
常用的：obj.style.width
方式2：
obj.style["attr"]  这种方式的优点在于可以直接传递参数进去，便于封装成函数。

2.学习了获取内联式/外联式css样式的方法，不过有兼容性问题
IE678、opear支持:
obj.currentStyle.width =======   obj.currentStyle["width"]
IE9及其以上、其他标准浏览器支持：
window.getComputedStyle(目标对象,伪类).width = window.getComputedStyle(目标对象,伪类)["width"]

3.在写封装animate2时遇到一个问题，有点蒙啊，定时器和for的执行顺序。为什么我使用lastTarget去记录
for循环最后一个执行的属性的当前值 和 目标值相等时清除定时器会不起作用？？？老师使用一
个flag的真相是什么？===定时器每隔30秒执行一次function，也就是30秒刷新一次flag，不断的刷新flag，直到
所有的属性当前值和target值都相等时，在此刷新定时器时，flag为ture并且所有的属性值都等于target了？？？
逻辑上这样理解并不对。
for循环不是依次执行的，不然也不会出现最开始我写的那样，某一个属性到达了target值，其他属性都还没
到达。如果是依次执行的，那肯定是这样的数据
【800（target为800），15（target为400），0（target为10）】，
一个完成剩下的正在执行或等待。但是实际数据确实这样的
【380（target为800），148（target为400），10（target为10）】，
有一个到达了，其他两个不是按照顺序执行的。
可见定时器是异步的【多线程的】！！！
对呀！定时器是多线程的不正是咱们想要的吗？不然也不会出现所有属性同时改变的效果！就应该是异步才对！
如果是同步的话你会肉眼看到，盒子先变宽，然后在向上移，最后在变高。
异步的结果就是所有的属性同时改变。
但是我记得有些电脑是单核的，只有一个定时器不存在来回切换达到异步的目的。这是一个问题。

4. 回调函数：等某个一函数A执行完就去执行某个函数B,称B 为: 回调函数

5. 封装的getStyle(obj,attr)方法，获取的是盒子实际的宽度，如果盒子没有宽高且没有内容：返回0px。
如果盒子没有宽高但是有内容：则返回是盒子实际被孩子撑起的宽高。如果盒子有宽高则返回盒子自己写的宽高！！